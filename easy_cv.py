#! /usr/bin/python
try:
    from jinja2 import Environment, FileSystemLoader
except ImportError as msg:
    print("ImportError: %s" % msg)
    exit(1)
try:
    from yaml import load, dump
except ImportError as msg:
    print("ImportError: %s" % msg)
    exit(1)

try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

import os, sys

# Copy from https://github.com/aclements/latexrun/blob/master/latexrun
import errno
import argparse
import shlex
import json
import subprocess
import re
import collections
import hashlib
import shutil
import curses
import filecmp
import io
import traceback
import time

try:
    sys.path.insert(0, './latexrun')
    from latexrun import *
except ImportError:
    print("ImportError: latexrun cannot be found. please run `git submodule update --recursive --remote` first to obtain it first!")
    exit(1)



# Capture our current directory
THIS_DIR = os.path.realpath(os.path.dirname(os.path.abspath(__file__)))
TEMP_DIR = os.path.join(THIS_DIR, "templates{0}sections_template_default".format(os.sep))
BUILD_DIR = os.path.join(THIS_DIR, "build")
DEFAULT_TEMPLATE = u'cv.tex'
TEXLIVEONFLY = os.path.join(THIS_DIR, 'tools{}texliveonfly.py'.format(os.sep))

MACROS_CONF = {
    "STYLE_DIR": os.path.join(THIS_DIR, "includes{0}cls".format(os.sep)),
    "MACROS": os.path.join(THIS_DIR, "includes{0}macros".format(os.sep)),
    "BIBSTYLE": os.path.join(THIS_DIR, "includes{0}bibstyle".format(os.sep))
}


def get_style(style_path=MACROS_CONF["STYLE_DIR"], style_filename="myRes"):
    return os.path.join(style_path, style_filename).replace('\\', '/')


def get_amcros(macro_path=MACROS_CONF["MACROS"]):
    return [os.path.join(macro_path, f).replace('\\', '/') for f in os.listdir(macro_path)]


def get_tex_doc(config, **options):
    """Generate tex code"""

    template_dir = options.get("template_dir", TEMP_DIR)
    template_filename = options.get("template", DEFAULT_TEMPLATE)
    j2_env = Environment(loader=FileSystemLoader(template_dir),
                         trim_blocks=True)

    if "macros" in config:
        pass
    else:
        config["macros"] = get_amcros()

    if "stylefile" in config:
        pass
    else:
        config["stylefile"] = get_style()

    return j2_env.get_template(template_filename).render(
        {
            "cv": config
        }
    )


def gen_tex_file(tex_doc, filename="example.tex", overwrite_handler=None):
    """Write the tex code into a file"""
    add_msg = "%% This file is generated by Jinja2"

    filename = os.path.join(BUILD_DIR, filename).replace('\\', '/')

    if os.path.exists(filename):
        if not (overwrite_handler is None):
            if not overwrite_handler(filename):
                return False

    with open(filename, 'w') as texf:
        texf.write("%s\n" % add_msg)
        texf.write(tex_doc)
    return True


def build_tex_file(tex_file, latex_cmd='pdflatex', latex_args=[], nowarns=True, output=None,
bibtex_cmd='bibtex', bibtex_args=[], max_iterations=10):
    """Build the latex code into a PDF"""
    # A note about encodings: POSIX encoding is a mess; TeX encoding
    # is a disaster.  Our goal is to make things no worse, so we want
    # byte-accurate round-tripping of TeX messages.  Since TeX
    # messages are *basically* text, we use strings and
    # surrogateescape'ing for both input and output.  I'm not fond of
    # setting surrogateescape globally, but it's far easier than
    # dealing with every place we pass TeX output through.
    # Conveniently, JSON can round-trip surrogateescape'd strings, so
    # our control database doesn't need special handling.
    sys.stdout = io.TextIOWrapper(
        sys.stdout.buffer, encoding=sys.stdout.encoding,
        errors='surrogateescape', line_buffering=sys.stdout.line_buffering)
    sys.stderr = io.TextIOWrapper(
        sys.stderr.buffer, encoding=sys.stderr.encoding,
        errors='surrogateescape', line_buffering=sys.stderr.line_buffering)

    Message.setup_color('auto')

    # Open control database.
    dbpath = os.path.join(BUILD_DIR, '.latexrun.db')
    if not os.path.exists(dbpath) and os.path.exists('.latexrun.db'):
        # The control database used to live in the source directory.
        # Support this for backwards compatibility.
        dbpath = '.latexrun.db'
    try:
        db = DB(dbpath)
    except (ValueError, OSError) as e:
        print('error opening {}: {}'.format(e.filename if hasattr(e, 'filename')
                                            else dbpath, e), file=sys.stderr)
        debug_exc()
        sys.exit(1)

    # Build
    try:
        #task_install_deps = LaTeX(db, tex_file, TEXLIVEONFLY, [], BUILD_DIR, True)
        task_latex = LaTeX(db, tex_file, latex_cmd, latex_args,
                           BUILD_DIR, nowarns)
        task_commit = LaTeXCommit(db, task_latex, output)
        task_bibtex = BibTeX(db, task_latex, bibtex_cmd, bibtex_args,
                             nowarns, BUILD_DIR)
        tasks = [task_latex, task_commit, task_bibtex]
        stable = run_tasks(tasks, max_iterations)

        # Print final task output and gather exit status
        status = 0
        for task in tasks:
            status = max(task.report(), status)

        if not stable:
            print('error: files are still changing after {} iterations; giving up'
                  .format(max_iterations), file=sys.stderr)
            status = max(status, 1)
    except TaskError as e:
        print(str(e), file=sys.stderr)
        debug_exc()
        status = 1

    # Report final status, if interesting
    fstatus = 'There were errors' if task_commit is None else task_commit.status
    if fstatus:
        #output = args.output
        if output is None:
            if task_latex.get_outname() is not None:
                output = os.path.basename(task_latex.get_outname())
            else:
                output = 'output'
        if Message._color:
            terminfo.send('bold', ('setaf', 1))
        print('{}; {} not updated'.format(fstatus, output))
        if Message._color:
            terminfo.send('sgr0')
    sys.exit(status)    

if __name__ == "__main__":
    content = load(open("_config.yaml", "r"))
    gen_tex_file(get_tex_doc(config=content), filename="long_full_2018.tex")
    build_tex_file(tex_file="long_full_2018.tex")
    #gen_tex_file(get_tex_doc(config=content), filename="long_full_2018.tex")
    #gen_tex_file(get_tex_doc(config=content), filename="long_intern_2019.tex")
